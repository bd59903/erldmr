#summary Distributed Map/Reduce in Erlang

= Distributed Map/Reduce in Erlang =

* Eric Day *

*_http://code.google.com/p/erldmr/_*

----

=== Abstract ===

This project was inspired by the !MapReduce programming model developed at Google `[1]`. While the Google model focuses on large batch-style processing for massive amounts of data and returning analytical results, this lightweight and simplified implementation focuses more on everyday applications, and how they can harness the same power the model provides. The current implementation serves as a prototype and leaves out some the advanced features and refinements presented in the Google paper. Potential paths for development for this implementation are mentioned in section 6, "Improvements".

The model used here uses two core ideas provided by functional languages: map and reduce (or sometimes referred to as fold). Map is the act of executing (or "mapping") a given function over each item in a list. Reduce (or fold) is the act of collapsing a list of items into a smaller set (or single item) based on a given function. This paper explores a method of distributing these operations over a number of nodes, which may exist on separate physical machines. This provides enhanced performance through parallel execution. Along with retrieving information about individual items stored within each node, this implementation also supports the ability for the map function to mutate the stored objects stored. Applications can use this in order to create dynamic data storage, which then extends to database oriented applications.

This implementation leverages many of the features functional languages provide to ease in deployment and testing. Treating functions as a first class object (or variables) is one of the key components to constructing quick tests and getting feedback since it allows you to define your function on the fly. You also have the built-in functions (bifs) and standard runtime modules within Erlang at your disposal when constructing your map and reduce functions. All code and supporting documentation for this project can be found at the URL given at the top of this paper.


=== 1 Introduction ===

* 1.1 Simplified Model *

One major simplification made in this implementation is not requiring an underlying global filesystem. The Google implementation is built upon their own file system (GFS) `[2]` which provides fast data access and fault-tolerance. The implementation described in this paper only deals with application level RAM-based storage, but persistent solutions are discussed in section 6. Not requiring a specific underlying filesystem allows for faster deployment due to less dependencies and the ability to start nodes any system with the Erlang runtime system.

* 1.2 Functional Roots *

* 1.3 Why Erlang *

=== 2 Implementation ===

* 2.2 Client Interface *

* 2.1 Server Interface *

* 2.4 Server Details *

=== 3 Testing: Numerical Computation ===

=== 4 Testing: Database Application ===

=== 5 Performance ===

* 5.1 One Node *

* 5.2 One Machine *

* 5.3 Three Machines *

* 5.4 Many Machines *

=== 6 Improvements ===

* 6.1 Persistent Storage *

File Scan (dets), B-Tree, Mnesia (get replication)

* 6.2 Redundancy *

* 6.3 Isolated Databases *

* 6.4 Access Control Lists *

* 6.5 External Interfaces *

TCP, Send code as query, compile, map, other lang bindings

=== 7 Conclusion ===

=== References ===

{{{

[1] Jeffrey Dean and Sanjay Ghemawat. MapReduce: Simplified Data Processing on Large Clusters. http://labs.google.com/papers/mapreduce.html.

[2] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google File System. http://labs.google.com/papers/gfs.html.

}}}
